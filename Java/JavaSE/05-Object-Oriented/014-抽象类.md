## 抽象类

### 1. 抽象方法和抽象类

##### 抽象方法和抽象类的规则

- 抽象类，抽象方法必须由 abstract 修饰
- 抽象方法不能有方法体
- 抽象类不能够实例化，**抽象类的构造方法主要用于被子类调用**。
- 抽象类可以包含**成员变量、方法（普通方法和抽象方法）、构造器、初始化块、内部类（接口、枚举）**。
- **含有抽象方法的类，只能是抽象类：**
  - **直接定义一个抽象方法**。
  - **继承一个抽象父类，但没有完全实现父类包含的抽象方法**。
  - **实现了一个接口，但没有完全实现接口包含的抽象方法**。



<font color="red">当使用 abstract 修饰类时，表明这个类只能被继承；当使用 abstract 修饰方法时，表明这个方法必须由子类提供实现（即重写）。而 final 修饰的类不能被继承，final 修饰的方法不能被重写。**因此 final 和 abstract 永远不能同时使用**。</font>

abstract 不能用于修饰成员变量，不能用于修饰局部变量，也不能用于修饰构造器。

<font color="red">当使用 static 修饰一个方法时，表明这个方法属于该类本身，即通过类就可调用该方法，但如果该方法被定义成抽象方法，则将导致通过该类来调用该方法时出现错误（调用了一个没有方法体的方法肯定会引起错误）。**因此 static 和 abstract 不能同时修饰某个方法**，即没有所谓的类抽象方法。</font>

注意：static 和 abstract 并不是绝对互斥的，**static 和 abstract** 虽然不能同时修饰某个方法，但它们**可以同时修饰内部类**。

<font color="red">abstract 关键字修饰的方法必须被其子类重写才有意义，否则这个方法将永远不会有方法体，因此 abstract 方法不能定义为 private 访问权限，即 **private 和 abstract 不能同时修饰方法**。</font>



### 2. 抽象类的作用

模板模式的一些简单规则：

- 抽象父类可以只定义需要使用的某些方法，把不能实现的部分抽象成抽象方法，留给其子类去实现。